open Asttypes
open Types
open Typedtree

(* generated by ocamltarzan and adjusted to not show 
 * the xxx_loc and xxx_env fields.
 * See ast_cmt.ml top comment if you have issues compiling this file.
 *)

let vof_array f x = Ocaml.vof_list f (Array.to_list x)

module Ident = struct
  let vof_t x = Ocaml.VString (Ident.name x)
end
module Longident = struct
  let vof_t _x = Ocaml.VString "LongIdent"
end
module Path = struct
  let vof_t x = Ocaml.VString (Path.name x)
end

module Location = struct
  let vof_t _x = Ocaml.VUnit
end

module Env = struct
  let vof_t _x = Ocaml.VUnit
end

module Concr = struct
  let vof_t _x = Ocaml.VUnit
end
module Meths = struct
  let vof_t _f _x = Ocaml.VUnit
end
module Primitive = struct
    let vof_description _x = Ocaml.VUnit
end
(* todo: in graph_code_cmt.ml path_resolve_module I think does not do
 * a lookup, so if you use Types below you will get lots of lookup_fail
 * when building the codegraph
 *)
module Types_ = struct
    let vof_value_description _x = Ocaml.VUnit
    let vof_class_declaration _x = Ocaml.VUnit
    let vof_class_type _x = Ocaml.VUnit
    let vof_class_signature _x = Ocaml.VUnit
    let vof_module_type _x = Ocaml.VUnit
    let vof_signature _x = Ocaml.VUnit
    let vof_type_declaration _x = Ocaml.VUnit
    let vof_exception_declaration _x = Ocaml.VUnit
    let vof_class_type_declaration _x = Ocaml.VUnit
    let vof_extension_constructor _x = Ocaml.VUnit
end

let vof_loc _f _x = Ocaml.VUnit
let vof_constant _x = Ocaml.VUnit
let vof_constructor_description _x = Ocaml.VUnit
let vof_label _x = Ocaml.VUnit
let vof_label_description _x = Ocaml.VUnit
let vof_closed_flag _x = Ocaml.VUnit
let vof_rec_flag _x = Ocaml.VUnit
let vof_partial _x =  Ocaml.VUnit
let vof_optional _x = Ocaml.VUnit

let vof_direction_flag _x = Ocaml.VUnit
let vof_override_flag _x = Ocaml.VUnit
let vof_mutable_flag _x = Ocaml.VUnit
let vof_private_flag _x = Ocaml.VUnit
let vof_virtual_flag _x = Ocaml.VUnit

let vof_attributes _x = Ocaml.VUnit

let vof_attribute _x = Ocaml.VUnit


let rec vof_type_expr { desc = v_desc; level = v_level; id = v_id; scope = _TODO } =
  let bnds = [] in
  let arg = Ocaml.vof_int v_id in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_level in
  let bnd = ("level", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_desc v_desc in
  let bnd = ("desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_type_desc =
  function
  | Tvar v1 ->
      let v1 = Ocaml.vof_option Ocaml.vof_string v1
      in Ocaml.VSum (("Tvar", [ v1 ]))
  | Tarrow ((v1, v2, v3, v4)) ->
      let v1 = vof_label v1
      and v2 = vof_type_expr v2
      and v3 = vof_type_expr v3
      and v4 = vof_commutable v4
      in Ocaml.VSum (("Tarrow", [ v1; v2; v3; v4 ]))
  | Ttuple v1 ->
      let v1 = Ocaml.vof_list vof_type_expr v1
      in Ocaml.VSum (("Ttuple", [ v1 ]))
  | Tconstr ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = Ocaml.vof_list vof_type_expr v2
      and v3 = Ocaml.vof_ref vof_abbrev_memo v3
      in Ocaml.VSum (("Tconstr", [ v1; v2; v3 ]))
  | Tobject ((v1, v2)) ->
      let v1 = vof_type_expr v1
      and v2 =
        Ocaml.vof_ref
          (Ocaml.vof_option
             (fun (v1, v2) ->
                let v1 = Path.vof_t v1
                and v2 = Ocaml.vof_list vof_type_expr v2
                in Ocaml.VTuple [ v1; v2 ]))
          v2
      in Ocaml.VSum (("Tobject", [ v1; v2 ]))
  | Tfield ((v1, v2, v3, v4)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_field_kind v2
      and v3 = vof_type_expr v3
      and v4 = vof_type_expr v4
      in Ocaml.VSum (("Tfield", [ v1; v2; v3; v4 ]))
  | Tnil -> Ocaml.VSum (("Tnil", []))
  | Tlink v1 -> let v1 = vof_type_expr v1 in Ocaml.VSum (("Tlink", [ v1 ]))
  | Tsubst v1 -> let v1 = vof_type_expr v1 in Ocaml.VSum (("Tsubst", [ v1 ]))
  | Tvariant v1 ->
      let v1 = vof_row_desc v1 in Ocaml.VSum (("Tvariant", [ v1 ]))
  | Tunivar v1 ->
      let v1 = Ocaml.vof_option Ocaml.vof_string v1
      in Ocaml.VSum (("Tunivar", [ v1 ]))
  | Tpoly ((v1, v2)) ->
      let v1 = vof_type_expr v1
      and v2 = Ocaml.vof_list vof_type_expr v2
      in Ocaml.VSum (("Tpoly", [ v1; v2 ]))
  | Tpackage ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = Ocaml.vof_list Longident.vof_t v2
      and v3 = Ocaml.vof_list vof_type_expr v3
      in Ocaml.VSum (("Tpackage", [ v1; v2; v3 ]))
and vof_row_desc {
                 row_fields = v_row_fields;
                 row_more = v_row_more;
                 row_bound = v_row_bound;
                 row_closed = v_row_closed;
                 row_fixed = v_row_fixed;
                 row_name = v_row_name
               } =
  let bnds = [] in
  let arg =
    Ocaml.vof_option
      (fun (v1, v2) ->
         let v1 = Path.vof_t v1
         and v2 = Ocaml.vof_list vof_type_expr v2
         in Ocaml.VTuple [ v1; v2 ])
      v_row_name in
  let bnd = ("row_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_bool v_row_fixed in
  let bnd = ("row_fixed", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_bool v_row_closed in
  let bnd = ("row_closed", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_unit v_row_bound in
  let bnd = ("row_bound", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_expr v_row_more in
  let bnd = ("row_more", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_label v1
         and v2 = vof_row_field v2
         in Ocaml.VTuple [ v1; v2 ])
      v_row_fields in
  let bnd = ("row_fields", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_row_field =
  function
  | Rpresent v1 ->
      let v1 = Ocaml.vof_option vof_type_expr v1
      in Ocaml.VSum (("Rpresent", [ v1 ]))
  | Reither ((v1, v2, v3, v4)) ->
      let v1 = Ocaml.vof_bool v1
      and v2 = Ocaml.vof_list vof_type_expr v2
      and v3 = Ocaml.vof_bool v3
      and v4 = Ocaml.vof_ref (Ocaml.vof_option vof_row_field) v4
      in Ocaml.VSum (("Reither", [ v1; v2; v3; v4 ]))
  | Rabsent -> Ocaml.VSum (("Rabsent", []))
and vof_abbrev_memo =
  function
  | Mnil -> Ocaml.VSum (("Mnil", []))
  | Mcons ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_private_flag v1
      and v2 = Path.vof_t v2
      and v3 = vof_type_expr v3
      and v4 = vof_type_expr v4
      and v5 = vof_abbrev_memo v5
      in Ocaml.VSum (("Mcons", [ v1; v2; v3; v4; v5 ]))
  | Mlink v1 ->
      let v1 = Ocaml.vof_ref vof_abbrev_memo v1
      in Ocaml.VSum (("Mlink", [ v1 ]))
and vof_field_kind =
  function
  | Fvar v1 ->
      let v1 = Ocaml.vof_ref (Ocaml.vof_option vof_field_kind) v1
      in Ocaml.VSum (("Fvar", [ v1 ]))
  | Fpresent -> Ocaml.VSum (("Fpresent", []))
  | Fabsent -> Ocaml.VSum (("Fabsent", []))
and vof_commutable =
  function
  | Cok -> Ocaml.VSum (("Cok", []))
  | Cunknown -> Ocaml.VSum (("Cunknown", []))
  | Clink v1 ->
      let v1 = Ocaml.vof_ref vof_commutable v1
      in Ocaml.VSum (("Clink", [ v1 ]))

let vof_type_expr_show_all x = vof_type_expr x

let __vof_type_expr _x = ()

let rec vof_pattern {
                pat_attributes = _v_pat_attributes;
                pat_desc = v_pat_desc;
                pat_loc = _v_pat_loc;
                pat_extra = _v_pat_extra;
                pat_type = _v_pat_type;
                pat_env = _v_pat_env
              } =
(*
  let bnds = [] in
  let arg = Env.vof_t v_pat_env in
  let bnd = ("pat_env", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_expr v_pat_type in
  let bnd = ("pat_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_pat_extra v1
         and v2 = Location.vof_t v2
         in Ocaml.VTuple [ v1; v2 ])
      v_pat_extra in
  let bnd = ("pat_extra", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_pat_loc in
  let bnd = ("pat_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_pattern_desc v_pat_desc in
  let bnd = ("pat_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_pattern_desc v_pat_desc

and vof_pat_extra =
  function
  | Tpat_constraint v1 ->
      let v1 = vof_core_type v1 in Ocaml.VSum (("Tpat_constraint", [ v1 ]))
  | Tpat_type ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      in Ocaml.VSum (("Tpat_type", [ v1; v2 ]))
  | Tpat_unpack -> Ocaml.VSum (("Tpat_unpack", []))
  | Tpat_open (_, _, _) -> failwith "Tpat_open"
and vof_pattern_desc =
  function
  | Tpat_any -> Ocaml.VSum (("Tpat_any", []))
  | Tpat_var ((v1, v2)) ->
      let v1 = Ident.vof_t v1
      and v2 = vof_loc Ocaml.vof_string v2
      in Ocaml.VSum (("Tpat_var", [ v1; v2 ]))
  | Tpat_alias ((v1, v2, v3)) ->
      let v1 = vof_pattern v1
      and v2 = Ident.vof_t v2
      and v3 = vof_loc Ocaml.vof_string v3
      in Ocaml.VSum (("Tpat_alias", [ v1; v2; v3 ]))
  | Tpat_constant v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("Tpat_constant", [ v1 ]))
  | Tpat_tuple v1 ->
      let v1 = Ocaml.vof_list vof_pattern v1
      in Ocaml.VSum (("Tpat_tuple", [ v1 ]))
  | Tpat_construct ((v1, v2, v3)) ->
      let v1 = vof_loc Longident.vof_t v1
      and v2 = vof_constructor_description v2
      and v3 = Ocaml.vof_list vof_pattern v3
      in Ocaml.VSum (("Tpat_construct", [ v1; v2; v3 ]))
  | Tpat_variant ((v1, v2, v3)) ->
      let v1 = vof_label v1
      and v2 = Ocaml.vof_option vof_pattern v2
      and v3 = Ocaml.vof_ref vof_row_desc v3
      in Ocaml.VSum (("Tpat_variant", [ v1; v2; v3 ]))
  | Tpat_record ((v1, v2)) ->
      let v1 =
        Ocaml.vof_list
          (fun (v1, v2, v3) ->
             let v1 = vof_loc Longident.vof_t v1
             and v2 = vof_label_description v2
             and v3 = vof_pattern v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v1
      and v2 = vof_closed_flag v2
      in Ocaml.VSum (("Tpat_record", [ v1; v2 ]))
  | Tpat_array v1 ->
      let v1 = Ocaml.vof_list vof_pattern v1
      in Ocaml.VSum (("Tpat_array", [ v1 ]))
  | Tpat_or ((v1, v2, v3)) ->
      let v1 = vof_pattern v1
      and v2 = vof_pattern v2
      and v3 = Ocaml.vof_option vof_row_desc v3
      in Ocaml.VSum (("Tpat_or", [ v1; v2; v3 ]))
  | Tpat_lazy v1 ->
      let v1 = vof_pattern v1 in Ocaml.VSum (("Tpat_lazy", [ v1 ]))
and vof_expression {
                   exp_desc = v_exp_desc;
                   exp_loc = _v_exp_loc;
                   exp_extra = _v_exp_extra;
                   exp_type = _v_exp_type;
                   exp_env = _v_exp_env;
                   exp_attributes = _TODO;
                 } =
(*
  let bnds = [] in
  let arg = Env.vof_t v_exp_env in
  let bnd = ("exp_env", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_expr v_exp_type in
  let bnd = ("exp_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_exp_extra v1
         and v2 = Location.vof_t v2
         in Ocaml.VTuple [ v1; v2 ])
      v_exp_extra in
  let bnd = ("exp_extra", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_exp_loc in
  let bnd = ("exp_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_expression_desc v_exp_desc in
  let bnd = ("exp_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_expression_desc v_exp_desc

and vof_exp_extra =
  function
  | Texp_constraint v1 ->
      let v1 = vof_core_type v1
      in Ocaml.VSum (("Texp_constraint", [ v1 ]))
  | Texp_open ((v1, v2, v3, v4)) ->
      let v1 = vof_override_flag v1
      and v2 = Path.vof_t v2
      and v3 = vof_loc Longident.vof_t v3
      and v4 = Env.vof_t v4
      in Ocaml.VSum (("Texp_open", [ v1; v2; v3; v4 ]))

  | Texp_poly v1 ->
      let v1 = Ocaml.vof_option vof_core_type v1
      in Ocaml.VSum (("Texp_poly", [ v1 ]))
  | Texp_newtype v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Texp_newtype", [ v1 ]))
  | Texp_coerce (_v1, _v2) ->
    failwith "Todo:Texp_coerce"
and vof_expression_desc =
  function
  | Texp_ident ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = Types_.vof_value_description v3
      in Ocaml.VSum (("Texp_ident", [ v1; v2; v3 ]))
  | Texp_constant v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("Texp_constant", [ v1 ]))
  | Texp_let ((v1, v2, v3)) ->
      let v1 = vof_rec_flag v1
      and v2 = Ocaml.vof_list vof_value_binding v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Texp_let", [ v1; v2; v3 ]))
  | Texp_function ({arg_label = v1; cases = v2; partial = v3; param = _TODO}) ->
      let v1 = vof_label v1
      and v2 = Ocaml.vof_list vof_case v2
      and v3 = vof_partial v3
      in Ocaml.VSum (("Texp_function", [ v1; v2; v3 ]))
  | Texp_apply ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 =
        Ocaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_label v1
             and v2 = Ocaml.vof_option vof_expression v2
             in Ocaml.VTuple [ v1; v2 ])
          v2
      in Ocaml.VSum (("Texp_apply", [ v1; v2 ]))
  | Texp_match ((v1, v2, v3, _v4)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_list vof_case v2
      and v3 = vof_partial v3
      and v4 = Ocaml.VString "TODO extension_constructor"
      in Ocaml.VSum (("Texp_match", [ v1; v2; v3; v4 ]))
  | Texp_try ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_list vof_case v2
      in Ocaml.VSum (("Texp_try", [ v1; v2 ]))
  | Texp_tuple v1 ->
      let v1 = Ocaml.vof_list vof_expression v1
      in Ocaml.VSum (("Texp_tuple", [ v1 ]))

  | Texp_construct ((v1, v2, v3)) ->
      let v1 = vof_loc Longident.vof_t v1
      and v2 = vof_constructor_description v2
      and v3 = Ocaml.vof_list vof_expression v3
      in Ocaml.VSum (("Texp_construct", [ v1; v2; v3 ]))

  | Texp_variant ((v1, v2)) ->
      let v1 = vof_label v1
      and v2 = Ocaml.vof_option vof_expression v2
      in Ocaml.VSum (("Texp_variant", [ v1; v2 ]))

  | Texp_record ({fields = v1; extended_expression = v2; representation = _TODO}) ->
      let v1 =
        vof_array
          (fun (v1, v2) ->
             let v1 = vof_label_description v1
             and v2 = vof_record_label_definition v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      and v2 = Ocaml.vof_option vof_expression v2
      in Ocaml.VSum (("Texp_record", [ v1; v2 ]))
  | Texp_field ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = vof_label_description v3
      in Ocaml.VSum (("Texp_field", [ v1; v2; v3 ]))
  | Texp_setfield ((v1, v2, v3, v4)) ->
      let v1 = vof_expression v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = vof_label_description v3
      and v4 = vof_expression v4
      in Ocaml.VSum (("Texp_setfield", [ v1; v2; v3; v4 ]))

  | Texp_array v1 ->
      let v1 = Ocaml.vof_list vof_expression v1
      in Ocaml.VSum (("Texp_array", [ v1 ]))
  | Texp_ifthenelse ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      and v3 = Ocaml.vof_option vof_expression v3
      in Ocaml.VSum (("Texp_ifthenelse", [ v1; v2; v3 ]))
  | Texp_sequence ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Texp_sequence", [ v1; v2 ]))
  | Texp_while ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Texp_while", [ v1; v2 ]))
  | Texp_for ((v1, v2, v3, v4, v5, v6)) ->
      let v1 = Ident.vof_t v1
      and v2 = vof_loc Ocaml.vof_string v2
      and v3 = vof_expression v3
      and v4 = vof_expression v4
      and v5 = vof_direction_flag v5
      and v6 = vof_expression v6
      in Ocaml.VSum (("Texp_for", [ v1; v2; v3; v4; v5; v6 ]))
  | Texp_send ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_meth v2
      and v3 = Ocaml.vof_option vof_expression v3
      in Ocaml.VSum (("Texp_send", [ v1; v2; v3 ]))
  | Texp_new ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = Types_.vof_class_declaration v3
      in Ocaml.VSum (("Texp_new", [ v1; v2; v3 ]))
  | Texp_instvar ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = Path.vof_t v2
      and v3 = vof_loc Ocaml.vof_string v3
      in Ocaml.VSum (("Texp_instvar", [ v1; v2; v3 ]))
  | Texp_setinstvar ((v1, v2, v3, v4)) ->
      let v1 = Path.vof_t v1
      and v2 = Path.vof_t v2
      and v3 = vof_loc Ocaml.vof_string v3
      and v4 = vof_expression v4
      in Ocaml.VSum (("Texp_setinstvar", [ v1; v2; v3; v4 ]))
  | Texp_override ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 =
        Ocaml.vof_list
          (fun (v1, v2, v3) ->
             let v1 = Path.vof_t v1
             and v2 = vof_loc Ocaml.vof_string v2
             and v3 = vof_expression v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v2
      in Ocaml.VSum (("Texp_override", [ v1; v2 ]))
  | Texp_letmodule ((v1, v2, v3, v4)) ->
      let v1 = Ident.vof_t v1
      and v2 = vof_loc Ocaml.vof_string v2
      and v3 = vof_module_expr v3
      and v4 = vof_expression v4
      in Ocaml.VSum (("Texp_letmodule", [ v1; v2; v3; v4 ]))
  | Texp_assert v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("Texp_assert", [ v1 ]))
  | Texp_lazy v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("Texp_lazy", [ v1 ]))
  | Texp_object ((v1, v2)) ->
      let v1 = vof_class_structure v1
      and v2 = Ocaml.vof_list Ocaml.vof_string v2
      in Ocaml.VSum (("Texp_object", [ v1; v2 ]))
  | Texp_pack v1 ->
      let v1 = vof_module_expr v1 in Ocaml.VSum (("Texp_pack", [ v1 ]))
  | Texp_unreachable ->
      failwith "Texp_unreachable"
  | Texp_letexception (v1, v2) ->
    let v1 = vof_extension_constructor v1 in
    let v2 = vof_expression v2 in
    Ocaml.VSum (("Texp_letexception", [v1; v2]))
  | Texp_extension_constructor (_, _) ->
      failwith "Texp_extension_constructor"

and vof_meth =
  function
  | Tmeth_name v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Tmeth_name", [ v1 ]))
  | Tmeth_val v1 ->
      let v1 = Ident.vof_t v1 in Ocaml.VSum (("Tmeth_val", [ v1 ]))

and vof_record_label_definition = 
  function
  | Kept v1 -> 
    let v1 = vof_type_expr v1
    in Ocaml.VSum (("Kept", [ v1 ]))
  | Overridden (v1, v2) -> 
    let v1 = vof_loc Longident.vof_t v1
    and v2 = vof_expression v2
    in Ocaml.VSum (("Overriden", [ v1; v2 ]))


and vof_class_expr {
                   cl_desc = v_cl_desc;
                   cl_loc = _v_cl_loc;
                   cl_type = _v_cl_type;
                   cl_env = _v_cl_env;
                   cl_attributes = _TODO;
                 } =
(*
  let bnds = [] in
  let arg = Env.vof_t v_cl_env in
  let bnd = ("cl_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_class_type v_cl_type in
  let bnd = ("cl_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_cl_loc in
  let bnd = ("cl_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_expr_desc v_cl_desc in
  let bnd = ("cl_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_class_expr_desc v_cl_desc

and vof_class_expr_desc =
  function
  | Tcl_ident ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = Ocaml.vof_list vof_core_type v3
      in Ocaml.VSum (("Tcl_ident", [ v1; v2; v3 ]))
  | Tcl_structure v1 ->
      let v1 = vof_class_structure v1
      in Ocaml.VSum (("Tcl_structure", [ v1 ]))
  | Tcl_fun ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_label v1
      and v2 = vof_pattern v2
      and v3 =
        Ocaml.vof_list
          (fun (v1, v2, v3) ->
             let v1 = Ident.vof_t v1
             and v2 = vof_loc Ocaml.vof_string v2
             and v3 = vof_expression v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v3
      and v4 = vof_class_expr v4
      and v5 = vof_partial v5
      in Ocaml.VSum (("Tcl_fun", [ v1; v2; v3; v4; v5 ]))
  | Tcl_apply ((v1, v2)) ->
      let v1 = vof_class_expr v1
      and v2 =
        Ocaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_label v1
             and v2 = Ocaml.vof_option vof_expression v2
             in Ocaml.VTuple [ v1; v2 ])
          v2
      in Ocaml.VSum (("Tcl_apply", [ v1; v2 ]))
  | Tcl_let ((v1, v2, v3, v4)) ->
      let v1 = vof_rec_flag v1
      and v2 = Ocaml.vof_list vof_value_binding v2
      and v3 =
        Ocaml.vof_list
          (fun (v1, v2, v3) ->
             let v1 = Ident.vof_t v1
             and v2 = vof_loc Ocaml.vof_string v2
             and v3 = vof_expression v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v3
      and v4 = vof_class_expr v4
      in Ocaml.VSum (("Tcl_let", [ v1; v2; v3; v4 ]))
  | Tcl_constraint ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_class_expr v1
      and v2 = Ocaml.vof_option vof_class_type v2
      and v3 = Ocaml.vof_list Ocaml.vof_string v3
      and v4 = Ocaml.vof_list Ocaml.vof_string v4
      and v5 = Concr.vof_t v5
      in Ocaml.VSum (("Tcl_constraint", [ v1; v2; v3; v4; v5 ]))
  | Tcl_open (_, _, _, _, _) ->
    failwith "Tcl_open"

and vof_class_structure {
                        cstr_self = v_cstr_pat;
                        cstr_fields = v_cstr_fields;
                        cstr_type = v_cstr_type;
                        cstr_meths = v_cstr_meths
                      } =
  let bnds = [] in
  let arg = Meths.vof_t Ident.vof_t v_cstr_meths in
  let bnd = ("cstr_meths", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_class_signature v_cstr_type in
  let bnd = ("cstr_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_class_field v_cstr_fields in
  let bnd = ("cstr_fields", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_pattern v_cstr_pat in
  let bnd = ("cstr_pat", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_class_field { 
     cf_desc = v_cf_desc; 
     cf_loc = _v_cf_loc; 
     cf_attributes = _TODO;
    } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_cf_loc in
  let bnd = ("cf_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_field_desc v_cf_desc in
  let bnd = ("cf_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_class_field_desc v_cf_desc

and vof_class_field_kind =
  function
  | Tcfk_virtual v1 ->
      let v1 = vof_core_type v1 in Ocaml.VSum (("Tcfk_virtual", [ v1 ]))
  | Tcfk_concrete (_, v1) ->
      let v1 = vof_expression v1 in Ocaml.VSum (("Tcfk_concrete", [ v1 ]))
and vof_class_field_desc =
  function
  | Tcf_inherit ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_override_flag v1
      and v2 = vof_class_expr v2
      and v3 = Ocaml.vof_option Ocaml.vof_string v3
      and v4 =
        Ocaml.vof_list
          (fun (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = Ident.vof_t v2
             in Ocaml.VTuple [ v1; v2 ])
          v4
      and v5 =
        Ocaml.vof_list
          (fun (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = Ident.vof_t v2
             in Ocaml.VTuple [ v1; v2 ])
          v5
      in Ocaml.VSum (("Tcf_inher", [ v1; v2; v3; v4; v5 ]))
  | Tcf_val ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_loc Ocaml.vof_string v1
      and v2 = vof_mutable_flag v2
      and v3 = Ident.vof_t v3
      and v4 = vof_class_field_kind v4
      and v5 = Ocaml.vof_bool v5
      in Ocaml.VSum (("Tcf_val", [ v1; v2; v3; v4; v5 ]))
  | Tcf_method ((v1, v2, v3)) ->
      let v1 = vof_loc Ocaml.vof_string v1
      and v2 = vof_private_flag v2
      and v3 = vof_class_field_kind v3
      in Ocaml.VSum (("Tcf_meth", [ v1; v2; v3 ]))
  | Tcf_constraint ((v1, v2)) ->
      let v1 = vof_core_type v1
      and v2 = vof_core_type v2
      in Ocaml.VSum (("Tcf_constr", [ v1; v2 ]))
  | Tcf_initializer v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("Tcf_init", [ v1 ]))
  | Tcf_attribute _ ->
    failwith "TODO: Tcf_Attribute"
and vof_module_expr {
                    mod_desc = v_mod_desc;
                    mod_loc = _v_mod_loc;
                    mod_type = _v_mod_type;
                    mod_env = _v_mod_env;
                    mod_attributes = _TODO;
                  } =
(*
  let bnds = [] in
  let arg = Env.vof_t v_mod_env in
  let bnd = ("mod_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_module_type v_mod_type in
  let bnd = ("mod_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_mod_loc in
  let bnd = ("mod_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_module_expr_desc v_mod_desc in
  let bnd = ("mod_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_module_expr_desc v_mod_desc

and vof_module_type_constraint =
  function
  | Tmodtype_implicit -> Ocaml.VSum (("Tmodtype_implicit", []))
  | Tmodtype_explicit v1 ->
      let v1 = vof_module_type v1
      in Ocaml.VSum (("Tmodtype_explicit", [ v1 ]))
and vof_module_expr_desc =
  function
  | Tmod_ident ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      in Ocaml.VSum (("Tmod_ident", [ v1; v2 ]))
  | Tmod_structure v1 ->
      let v1 = vof_structure v1 in Ocaml.VSum (("Tmod_structure", [ v1 ]))
  | Tmod_functor ((v1, v2, v3, v4)) ->
      let v1 = Ident.vof_t v1
      and v2 = vof_loc Ocaml.vof_string v2
      and v3 = Ocaml.vof_option vof_module_type v3
      and v4 = vof_module_expr v4
      in Ocaml.VSum (("Tmod_functor", [ v1; v2; v3; v4 ]))
  | Tmod_apply ((v1, v2, v3)) ->
      let v1 = vof_module_expr v1
      and v2 = vof_module_expr v2
      and v3 = vof_module_coercion v3
      in Ocaml.VSum (("Tmod_apply", [ v1; v2; v3 ]))
  | Tmod_constraint ((v1, v2, v3, v4)) ->
      let v1 = vof_module_expr v1
      and v2 = Types_.vof_module_type v2
      and v3 = vof_module_type_constraint v3
      and v4 = vof_module_coercion v4
      in Ocaml.VSum (("Tmod_constraint", [ v1; v2; v3; v4 ]))
  | Tmod_unpack ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = Types_.vof_module_type v2
      in Ocaml.VSum (("Tmod_unpack", [ v1; v2 ]))
and vof_structure {
                  str_items = v_str_items;
                  str_type = v_str_type;
                  str_final_env = v_str_final_env
                } =
  let bnds = [] in
  let arg = Env.vof_t v_str_final_env in
  let bnd = ("str_final_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_signature v_str_type in
  let bnd = ("str_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_structure_item v_str_items in
  let bnd = ("str_items", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_structure_item {
                       str_desc = v_str_desc;
                       str_loc = _v_str_loc;
                       str_env = _v_str_env
                     } =
(*
  let bnds = [] in
  let arg = Env.vof_t v_str_env in
  let bnd = ("str_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_str_loc in
  let bnd = ("str_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_structure_item_desc v_str_desc in
  let bnd = ("str_desc", arg) in 
  let bnds = bnd :: bnds  in 
  Ocaml.VDict bnds
  *)
  vof_structure_item_desc v_str_desc


and vof_structure_item_desc =
  function
  | Tstr_eval (v1, _TODOattr) ->
      let v1 = vof_expression v1 in Ocaml.VSum (("Tstr_eval", [ v1 ]))
  | Tstr_value ((v1, v2)) ->
      let v1 = vof_rec_flag v1
      and v2 = Ocaml.vof_list vof_value_binding v2
      in Ocaml.VSum (("Tstr_value", [ v1; v2 ]))
  | Tstr_primitive v1 ->
      let v1 = vof_value_description v1
      in Ocaml.VSum (("Tstr_primitive", [ v1 ]))
  | Tstr_type (_recTODO, v1) ->
      let v1 = Ocaml.vof_list vof_type_declaration v1
      in Ocaml.VSum (("Tstr_type", [ v1 ]))
  | Tstr_exception v1 ->
      let v1 = vof_extension_constructor v1 in
      Ocaml.VSum (("Tstr_exception", [ v1]))
  | Tstr_module v1  ->
    let v1 = vof_module_binding v1
    in Ocaml.VSum (("Tstr_module", [ v1 ]))
  | Tstr_recmodule v1 ->
      let v1 = Ocaml.vof_list vof_module_binding v1
      in Ocaml.VSum (("Tstr_recmodule", [ v1 ]))
  | Tstr_modtype v1 ->
    let v1 = vof_module_type_declaration v1 in
    Ocaml.VSum (("Tstr_modtype", [ v1 ]))
  | Tstr_open v1  ->
    let v1 = vof_open_description v1 in
    Ocaml.VSum (("Tstr_open", [ v1 ]))
  | Tstr_class v1 ->
      let v1 =
        Ocaml.vof_list
          (fun (v1, v2) ->
             let v1 = vof_class_declaration v1
             and v2 = Ocaml.vof_list Ocaml.vof_string v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      in Ocaml.VSum (("Tstr_class", [ v1 ]))
  | Tstr_class_type v1 ->
      let v1 =
        Ocaml.vof_list
          (fun (v1, v2, v3) ->
             let v1 = Ident.vof_t v1
             and v2 = vof_loc Ocaml.vof_string v2
             and v3 = vof_class_type_declaration v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v1
      in Ocaml.VSum (("Tstr_class_type", [ v1 ]))

  | Tstr_include v1 ->
    let v1 = vof_include_declaration v1 in
    Ocaml.VSum (("Tstr_include", [ v1 ]))
  | Tstr_typext _ ->
    failwith "Tstr_typext"
  | Tstr_attribute _ ->
    failwith "Tstr_attribute"

and vof_module_coercion =
  function
  | Tcoerce_none -> Ocaml.VSum (("Tcoerce_none", []))
  | Tcoerce_structure _ ->
    failwith "Tcoerce_structure"
  | Tcoerce_functor ((v1, v2)) ->
      let v1 = vof_module_coercion v1
      and v2 = vof_module_coercion v2
      in Ocaml.VSum (("Tcoerce_functor", [ v1; v2 ]))
  | Tcoerce_primitive v1 ->
      let v1 = Primitive.vof_description v1
      in Ocaml.VSum (("Tcoerce_primitive", [ v1 ]))
  | Tcoerce_alias _ ->
    failwith "Tcoerce_alias"
        

and vof_module_type {
                    mty_desc = v_mty_desc;
                    mty_type = _v_mty_type;
                    mty_env = _v_mty_env;
                    mty_loc = _v_mty_loc;
                    mty_attributes = _TODO;
                  } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_mty_loc in
  let bnd = ("mty_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Env.vof_t v_mty_env in
  let bnd = ("mty_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_module_type v_mty_type in
  let bnd = ("mty_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_module_type_desc v_mty_desc in
  let bnd = ("mty_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_module_type_desc v_mty_desc

and vof_module_type_desc =
  function
  | Tmty_ident ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      in Ocaml.VSum (("Tmty_ident", [ v1; v2 ]))
  | Tmty_signature v1 ->
      let v1 = vof_signature v1 in Ocaml.VSum (("Tmty_signature", [ v1 ]))
  | Tmty_functor ((v1, v2, v3, v4)) ->
      let v1 = Ident.vof_t v1
      and v2 = vof_loc Ocaml.vof_string v2
      and v3 = Ocaml.vof_option vof_module_type v3
      and v4 = vof_module_type v4
      in Ocaml.VSum (("Tmty_functor", [ v1; v2; v3; v4 ]))
  | Tmty_with ((v1, v2)) ->
      let v1 = vof_module_type v1
      and v2 =
        Ocaml.vof_list
          (fun (v1, v2, v3) ->
             let v1 = Path.vof_t v1
             and v2 = vof_loc Longident.vof_t v2
             and v3 = vof_with_constraint v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v2
      in Ocaml.VSum (("Tmty_with", [ v1; v2 ]))
  | Tmty_typeof v1 ->
      let v1 = vof_module_expr v1 in Ocaml.VSum (("Tmty_typeof", [ v1 ]))
  | Tmty_alias _ ->
    failwith "Tmty_alias"
and vof_signature {
                  sig_items = v_sig_items;
                  sig_type = v_sig_type;
                  sig_final_env = v_sig_final_env
                } =
  let bnds = [] in
  let arg = Env.vof_t v_sig_final_env in
  let bnd = ("sig_final_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_signature v_sig_type in
  let bnd = ("sig_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_signature_item v_sig_items in
  let bnd = ("sig_items", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_signature_item {
                       sig_desc = v_sig_desc;
                       sig_env = _v_sig_env;
                       sig_loc = _v_sig_loc
                     } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_sig_loc in
  let bnd = ("sig_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Env.vof_t v_sig_env in
  let bnd = ("sig_env", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_signature_item_desc v_sig_desc in
  let bnd = ("sig_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_signature_item_desc v_sig_desc

and vof_signature_item_desc =
  function
  | Tsig_value v1  ->
    let v1 = vof_value_description v1
    in Ocaml.VSum (("Tsig_value", [ v1 ]))
  | Tsig_type (_recTODO, v1) ->
      let v1 = Ocaml.vof_list vof_type_declaration v1
      in Ocaml.VSum (("Tsig_type", [ v1 ]))
  | Tsig_exception (v1) ->
      let v1 = vof_extension_constructor v1
      in Ocaml.VSum (("Tsig_exception", [ v1; ]))
  | Tsig_module ((v1)) ->
      let v1 = vof_module_declaration v1
      in Ocaml.VSum (("Tsig_module", [ v1; ]))
  | Tsig_recmodule v1 ->
      let v1 = Ocaml.vof_list vof_module_declaration v1
      in Ocaml.VSum (("Tsig_recmodule", [ v1 ]))
  | Tsig_modtype ((v1)) ->
      let v1 = vof_module_type_declaration v1
      in Ocaml.VSum (("Tsig_modtype", [ v1; ]))

  | Tsig_open ((v1)) ->
      let v1 = vof_open_description v1
      in Ocaml.VSum (("Tsig_open", [ v1; ]))

  | Tsig_include ((v1)) ->
      let v1 = vof_include_description v1
      in Ocaml.VSum (("Tsig_include", [ v1 ]))
  | Tsig_class v1 ->
      let v1 = Ocaml.vof_list vof_class_description v1
      in Ocaml.VSum (("Tsig_class", [ v1 ]))
  | Tsig_class_type v1 ->
      let v1 = Ocaml.vof_list vof_class_type_declaration v1
      in Ocaml.VSum (("Tsig_class_type", [ v1 ]))
  | Tsig_typext _ ->
    failwith "Tsig_typext"
  | Tsig_attribute _ ->
    failwith "Tsig_attribute"
and vof_with_constraint =
  function
  | Twith_type v1 ->
      let v1 = vof_type_declaration v1 in Ocaml.VSum (("Twith_type", [ v1 ]))
  | Twith_module ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      in Ocaml.VSum (("Twith_module", [ v1; v2 ]))
  | Twith_typesubst v1 ->
      let v1 = vof_type_declaration v1
      in Ocaml.VSum (("Twith_typesubst", [ v1 ]))
  | Twith_modsubst ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      in Ocaml.VSum (("Twith_modsubst", [ v1; v2 ]))
and vof_core_type {
                  ctyp_desc = v_ctyp_desc;
                  ctyp_type = _v_ctyp_type;
                  ctyp_env = _v_ctyp_env;
                  ctyp_loc = _v_ctyp_loc;
                  ctyp_attributes = _TODO;
                } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_ctyp_loc in
  let bnd = ("ctyp_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Env.vof_t v_ctyp_env in
  let bnd = ("ctyp_env", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_expr v_ctyp_type in
  let bnd = ("ctyp_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_core_type_desc v_ctyp_desc in
  let bnd = ("ctyp_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_core_type_desc v_ctyp_desc

and vof_core_type_desc =
  function
  | Ttyp_any -> Ocaml.VSum (("Ttyp_any", []))
  | Ttyp_var v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Ttyp_var", [ v1 ]))
  | Ttyp_arrow ((v1, v2, v3)) ->
      let v1 = vof_label v1
      and v2 = vof_core_type v2
      and v3 = vof_core_type v3
      in Ocaml.VSum (("Ttyp_arrow", [ v1; v2; v3 ]))
  | Ttyp_tuple v1 ->
      let v1 = Ocaml.vof_list vof_core_type v1
      in Ocaml.VSum (("Ttyp_tuple", [ v1 ]))
  | Ttyp_constr ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = Ocaml.vof_list vof_core_type v3
      in Ocaml.VSum (("Ttyp_constr", [ v1; v2; v3 ]))
  | Ttyp_object ((v1, v2)) ->
      let v1 = Ocaml.vof_list vof_object_field v1
      and v2 = vof_closed_flag v2
      in Ocaml.VSum (("Ttyp_object", [ v1; v2 ]))

  | Ttyp_class ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = Ocaml.vof_list vof_core_type v3
      in Ocaml.VSum (("Ttyp_class", [ v1; v2; v3;]))
  | Ttyp_alias ((v1, v2)) ->
      let v1 = vof_core_type v1
      and v2 = Ocaml.vof_string v2
      in Ocaml.VSum (("Ttyp_alias", [ v1; v2 ]))
  | Ttyp_variant ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_list vof_row_field v1
      and v2 = vof_closed_flag v2
      and v3 = Ocaml.vof_option (Ocaml.vof_list vof_label) v3
      in Ocaml.VSum (("Ttyp_variant", [ v1; v2; v3 ]))
  | Ttyp_poly ((v1, v2)) ->
      let v1 = Ocaml.vof_list Ocaml.vof_string v1
      and v2 = vof_core_type v2
      in Ocaml.VSum (("Ttyp_poly", [ v1; v2 ]))
  | Ttyp_package v1 ->
      let v1 = vof_package_type v1 in Ocaml.VSum (("Ttyp_package", [ v1 ]))

and vof_object_field = function
  | OTtag (v1, v2, v3) ->
    let v1 = vof_loc Ocaml.vof_string v1
    and v2 = vof_attributes v2
    and v3 = vof_core_type v3
    in Ocaml.VSum ("OTtag", [ v1; v2; v3 ])
  | OTinherit _ ->
    failwith "OTinherit"

and vof_package_type {
                     pack_path = v_pack_name;
                     pack_fields = v_pack_fields;
                     pack_type = v_pack_type;
                     pack_txt = v_pack_txt
                   } =
  let bnds = [] in
  let arg = vof_loc Longident.vof_t v_pack_txt in
  let bnd = ("pack_txt", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_module_type v_pack_type in
  let bnd = ("pack_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_loc Longident.vof_t v1
         and v2 = vof_core_type v2
         in Ocaml.VTuple [ v1; v2 ])
      v_pack_fields in
  let bnd = ("pack_fields", arg) in
  let bnds = bnd :: bnds in
  let arg = Path.vof_t v_pack_name in
  let bnd = ("pack_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_row_field =
  function
  | Ttag ((v1, _vattrTODO, v2, v3)) ->
      let v1 = vof_label v1
      and v2 = Ocaml.vof_bool v2
      and v3 = Ocaml.vof_list vof_core_type v3
      in Ocaml.VSum (("Ttag", [ v1; v2; v3 ]))
  | Tinherit v1 ->
      let v1 = vof_core_type v1 in Ocaml.VSum (("Tinherit", [ v1 ]))
and vof_value_description {
                          val_desc = v_val_desc;
                          val_val = _v_val_val;
                          val_prim = _v_val_prim;
                          val_loc = _v_val_loc;

                          val_attributes = _TODO;
                          val_id = _TODO1;
                          val_name = _TODO2;
                        } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_val_loc in
  let bnd = ("val_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Ocaml.vof_string v_val_prim in
  let bnd = ("val_prim", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_value_description v_val_val in
  let bnd = ("val_val", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_core_type v_val_desc in
  let bnd = ("val_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_core_type v_val_desc

and vof_type_declaration {
                         typ_id = v_typ_id;
                         typ_name = v_typ_name;
                         typ_params = v_typ_params;
                         typ_type = v_typ_type;
                         typ_cstrs = v_typ_cstrs;
                         typ_kind = v_typ_kind;
                         typ_private = v_typ_private;
                         typ_manifest = v_typ_manifest;
                         typ_loc = v_typ_loc;
                         typ_attributes = v_typ_attributes
                       } =
  let bnds = [] in
  let arg = vof_attributes v_typ_attributes in
  let bnd = ("typ_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_typ_loc in
  let bnd = ("typ_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_core_type v_typ_manifest in
  let bnd = ("typ_manifest", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_private_flag v_typ_private in
  let bnd = ("typ_private", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_type_kind v_typ_kind in
  let bnd = ("typ_kind", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2, v3) ->
         let v1 = vof_core_type v1
         and v2 = vof_core_type v2
         and v3 = Location.vof_t v3
         in Ocaml.VTuple [ v1; v2; v3 ])
      v_typ_cstrs in
  let bnd = ("typ_cstrs", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_type_declaration v_typ_type in
  let bnd = ("typ_type", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_core_type v1
         and v2 = vof_variance v2
         in Ocaml.VTuple [ v1; v2 ])
      v_typ_params in
  let bnd = ("typ_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_typ_name in
  let bnd = ("typ_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_typ_id in
  let bnd = ("typ_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_type_kind =
  function
  | Ttype_abstract -> Ocaml.VSum (("Ttype_abstract", []))
  | Ttype_variant v1 ->
      let v1 = Ocaml.vof_list vof_constructor_declaration v1
      in Ocaml.VSum (("Ttype_variant", [ v1 ]))
  | Ttype_record v1 ->
      let v1 = Ocaml.vof_list vof_label_declaration v1
      in Ocaml.VSum (("Ttype_record", [ v1 ]))
  | Ttype_open ->
    failwith "Ttype_open"

and vof_class_type {
                   cltyp_desc = v_cltyp_desc;
                   cltyp_type = _v_cltyp_type;
                   cltyp_env = _v_cltyp_env;
                   cltyp_loc = _v_cltyp_loc;
                   cltyp_attributes = _TODO;
                 } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_cltyp_loc in
  let bnd = ("cltyp_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Env.vof_t v_cltyp_env in
  let bnd = ("cltyp_env", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_class_type v_cltyp_type in
  let bnd = ("cltyp_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_type_desc v_cltyp_desc in
  let bnd = ("cltyp_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_class_type_desc v_cltyp_desc

and vof_class_type_desc =
  function
  | Tcty_constr ((v1, v2, v3)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      and v3 = Ocaml.vof_list vof_core_type v3
      in Ocaml.VSum (("Tcty_constr", [ v1; v2; v3 ]))
  | Tcty_signature v1 ->
      let v1 = vof_class_signature v1
      in Ocaml.VSum (("Tcty_signature", [ v1 ]))
  | Tcty_arrow ((v1, v2, v3)) ->
      let v1 = vof_label v1
      and v2 = vof_core_type v2
      and v3 = vof_class_type v3
      in Ocaml.VSum (("Tcty_arrow", [ v1; v2; v3 ]))
  | Tcty_open (_, _, _, _, _) ->
    failwith "Tcty_open"

and vof_class_signature {
                        csig_self = v_csig_self;
                        csig_fields = v_csig_fields;
                        csig_type = v_csig_type;
                      } =
  let bnds = [] in
  let arg = Types_.vof_class_signature v_csig_type in
  let bnd = ("csig_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_class_type_field v_csig_fields in
  let bnd = ("csig_fields", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_core_type v_csig_self in
  let bnd = ("csig_self", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_class_type_field { 
      ctf_desc = v_ctf_desc; 
      ctf_loc = _v_ctf_loc;
      ctf_attributes = _TODO;
  } =
(*
  let bnds = [] in
  let arg = Location.vof_t v_ctf_loc in
  let bnd = ("ctf_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_type_field_desc v_ctf_desc in
  let bnd = ("ctf_desc", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
*)
  vof_class_type_field_desc v_ctf_desc

and vof_class_type_field_desc =
  function
  | Tctf_inherit v1 ->
      let v1 = vof_class_type v1 in Ocaml.VSum (("Tctf_inher", [ v1 ]))
  | Tctf_val v1 ->
      let v1 =
        (match v1 with
         | (v1, v2, v3, v4) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_mutable_flag v2
             and v3 = vof_virtual_flag v3
             and v4 = vof_core_type v4
             in Ocaml.VTuple [ v1; v2; v3; v4 ])
      in Ocaml.VSum (("Tctf_val", [ v1 ]))
  | Tctf_method v1 ->
      let v1 =
        (match v1 with
         | (v1, v2, v3, v4) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_private_flag v2
             and v3 = vof_virtual_flag v3
             and v4 = vof_core_type v4
             in Ocaml.VTuple [ v1; v2; v3; v4 ])
      in Ocaml.VSum (("Tctf_meth", [ v1 ]))
  | Tctf_constraint v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_core_type v1
             and v2 = vof_core_type v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Tctf_cstr", [ v1 ]))
  | Tctf_attribute _ ->
    failwith "Tctf_attribute"
and vof_class_declaration v = vof_class_infos vof_class_expr v
and vof_class_description v = vof_class_infos vof_class_type v
and vof_class_type_declaration v = vof_class_infos vof_class_type v


and vof_class_infos: 'a. ('a -> Ocaml.v) -> 'a class_infos -> Ocaml.v
 = fun _of_a x ->
   match x with
                  {
                    ci_virt = v_ci_virt;
                    ci_params = v_ci_params;
                    ci_id_name = v_ci_id_name;
                    ci_id_class = v_ci_id_class;
                    ci_id_class_type = v_ci_id_class_type;
                    ci_id_object = v_ci_id_object;
                    ci_id_typehash = v_ci_id_typesharp;
                    ci_expr = v_ci_expr;
                    ci_decl = v_ci_decl;
                    ci_type_decl = v_ci_type_decl;
                    ci_loc = v_ci_loc;
                    ci_attributes = _TODO;
                  } ->
  let bnds = [] in
  let arg = Location.vof_t v_ci_loc in
  let bnd = ("ci_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_class_type_declaration v_ci_type_decl in
  let bnd = ("ci_type_decl", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_class_declaration v_ci_decl in
  let bnd = ("ci_decl", arg) in
  let bnds = bnd :: bnds in
  let arg = _of_a v_ci_expr in
  let bnd = ("ci_expr", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_ci_id_typesharp in
  let bnd = ("ci_id_typesharp", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_ci_id_object in
  let bnd = ("ci_id_object", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_ci_id_class_type in
  let bnd = ("ci_id_class_type", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_ci_id_class in
  let bnd = ("ci_id_class", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_ci_id_name in
  let bnd = ("ci_id_name", arg) in
  let bnds = bnd :: bnds in
  let arg =
    Ocaml.vof_list
      (fun (v1, v2) ->
         let v1 = vof_core_type v1
         and v2 = vof_variance v2
         in Ocaml.VTuple [ v1; v2 ])
      v_ci_params in
  let bnd = ("ci_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_virtual_flag v_ci_virt in
  let bnd = ("ci_virt", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds


  
and vof_case {
               c_lhs = v_lhs;
               c_guard = _v_guard;
               c_rhs = v_rhs
             } =
  let v1 = vof_pattern v_lhs
  and v2 = vof_expression v_rhs
  in Ocaml.VTuple [ v1; v2 ]

and vof_value_binding {
                      vb_pat = v_vb_pat;
                      vb_expr = v_vb_expr;
                      vb_attributes = v_vb_attributes;
                      vb_loc = v_vb_loc
                    } =
  let bnds = [] in
  let arg = Location.vof_t v_vb_loc in
  let bnd = ("vb_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_attributes v_vb_attributes in
  let bnd = ("vb_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_expression v_vb_expr in
  let bnd = ("vb_expr", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_pattern v_vb_pat in
  let bnd = ("vb_pat", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_module_binding {
                         mb_id = v_mb_id;
                         mb_name = v_mb_name;
                         mb_expr = v_mb_expr;
                         mb_attributes = v_mb_attributes;
                         mb_loc = v_mb_loc
                       } =
  let bnds = [] in
  let arg = Location.vof_t v_mb_loc in
  let bnd = ("mb_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_attributes v_mb_attributes in
  let bnd = ("mb_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_module_expr v_mb_expr in
  let bnd = ("mb_expr", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_mb_name in
  let bnd = ("mb_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_mb_id in
  let bnd = ("mb_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_module_type_declaration {
                                mtd_id = v_mtd_id;
                                mtd_name = v_mtd_name;
                                mtd_type = v_mtd_type;
                                mtd_attributes = v_mtd_attributes;
                                mtd_loc = v_mtd_loc
                              } =
  let bnds = [] in
  let arg = Location.vof_t v_mtd_loc in
  let bnd = ("mtd_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_attributes v_mtd_attributes in
  let bnd = ("mtd_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_module_type v_mtd_type in
  let bnd = ("mtd_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_mtd_name in
  let bnd = ("mtd_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_mtd_id in
  let bnd = ("mtd_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_open_description {
                         open_path = v_open_path;
                         open_txt = v_open_txt;
                         open_override = v_open_override;
                         open_loc = v_open_loc;
                         open_attributes = v_open_attributes
                       } =
  let bnds = [] in
  let arg = Ocaml.vof_list vof_attribute v_open_attributes in
  let bnd = ("open_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_open_loc in
  let bnd = ("open_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_override_flag v_open_override in
  let bnd = ("open_override", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Longident.vof_t v_open_txt in
  let bnd = ("open_txt", arg) in
  let bnds = bnd :: bnds in
  let arg = Path.vof_t v_open_path in
  let bnd = ("open_path", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_include_infos: 'a. ('a -> Ocaml.v) -> 'a include_infos -> Ocaml.v
 = fun _of_a x ->
  match x with
                    {
                      incl_mod = v_incl_mod;
                      incl_type = v_incl_type;
                      incl_loc = v_incl_loc;
                      incl_attributes = v_incl_attributes
                    } ->
  let bnds = [] in
  let arg = Ocaml.vof_list vof_attribute v_incl_attributes in
  let bnd = ("incl_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_incl_loc in
  let bnd = ("incl_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_signature v_incl_type in
  let bnd = ("incl_type", arg) in
  let bnds = bnd :: bnds in
  let arg = _of_a v_incl_mod in
  let bnd = ("incl_mod", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_include_description v = vof_include_infos vof_module_type v
and vof_include_declaration v = vof_include_infos vof_module_expr v

and vof_extension_constructor {
                              ext_id = v_ext_id;
                              ext_name = v_ext_name;
                              ext_type = v_ext_type;
                              ext_kind = v_ext_kind;
                              ext_loc = v_ext_loc;
                              ext_attributes = v_ext_attributes
                            } =
  let bnds = [] in
  let arg = vof_attributes v_ext_attributes in
  let bnd = ("ext_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_ext_loc in
  let bnd = ("ext_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_extension_constructor_kind v_ext_kind in
  let bnd = ("ext_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = Types_.vof_extension_constructor v_ext_type in
  let bnd = ("ext_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_ext_name in
  let bnd = ("ext_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_ext_id in
  let bnd = ("ext_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and  vof_module_declaration {
                           md_id = v_md_id;
                           md_name = v_md_name;
                           md_type = v_md_type;
                           md_attributes = v_md_attributes;
                           md_loc = v_md_loc
                         } =
  let bnds = [] in
  let arg = Location.vof_t v_md_loc in
  let bnd = ("md_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_attributes v_md_attributes in
  let bnd = ("md_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_module_type v_md_type in
  let bnd = ("md_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_md_name in
  let bnd = ("md_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_md_id in
  let bnd = ("md_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_variance =
  function
  | Covariant -> Ocaml.VSum (("Covariant", []))
  | Contravariant -> Ocaml.VSum (("Contravariant", []))
  | Invariant -> Ocaml.VSum (("Invariant", []))

and vof_constructor_declaration {
                                cd_id = v_cd_id;
                                cd_name = v_cd_name;
                                cd_args = v_cd_args;
                                cd_res = v_cd_res;
                                cd_loc = v_cd_loc;
                                cd_attributes = v_cd_attributes
                              } =
  let bnds = [] in
  let arg = vof_attributes v_cd_attributes in
  let bnd = ("cd_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_cd_loc in
  let bnd = ("cd_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_core_type v_cd_res in
  let bnd = ("cd_res", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_constructor_arguments v_cd_args in
  let bnd = ("cd_args", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_cd_name in
  let bnd = ("cd_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_cd_id in
  let bnd = ("cd_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_constructor_arguments = function
  | Cstr_tuple xs -> Ocaml.vof_list vof_core_type xs
  | Cstr_record v1 -> 
      let v1 = Ocaml.vof_list vof_label_declaration v1
      in Ocaml.VSum (("Cstr_record", [ v1 ]))

and vof_label_declaration {
                          ld_id = v_ld_id;
                          ld_name = v_ld_name;
                          ld_mutable = v_ld_mutable;
                          ld_type = v_ld_type;
                          ld_loc = v_ld_loc;
                          ld_attributes = v_ld_attributes
                        } =
  let bnds = [] in
  let arg = vof_attributes v_ld_attributes in
  let bnd = ("ld_attributes", arg) in
  let bnds = bnd :: bnds in
  let arg = Location.vof_t v_ld_loc in
  let bnd = ("ld_loc", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_core_type v_ld_type in
  let bnd = ("ld_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_mutable_flag v_ld_mutable in
  let bnd = ("ld_mutable", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_loc Ocaml.vof_string v_ld_name in
  let bnd = ("ld_name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ident.vof_t v_ld_id in
  let bnd = ("ld_id", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and vof_extension_constructor_kind =
  function
  | Text_decl ((v1, v2)) ->
      let v1 = vof_constructor_arguments v1
      and v2 = Ocaml.vof_option vof_core_type v2
      in Ocaml.VSum (("Text_decl", [ v1; v2 ]))
  | Text_rebind ((v1, v2)) ->
      let v1 = Path.vof_t v1
      and v2 = vof_loc Longident.vof_t v2
      in Ocaml.VSum (("Text_rebind", [ v1; v2 ]))
