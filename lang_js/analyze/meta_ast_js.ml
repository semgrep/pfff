
(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_vof.cmo  pr_o.cmo /tmp/xxx.ml  *)

open Ast_js

let rec vof_tok _v = 
 (* Parse_info.vof_info v *)
 Ocaml.VUnit

and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 
  and _v2 = vof_tok v2 in 
  (* Ocaml.VTuple [ v1; v2 ] *)
  v1

let vof_bracket of_a (_t1, x, _t2) =
  of_a x
  
let vof_name v = vof_wrap Ocaml.vof_string v

let vof_resolved_name = function
  | Local -> Ocaml.VSum (("Local", []))
  | Param -> Ocaml.VSum (("Param", []))
  | NotResolved -> Ocaml.VSum (("NotResolved", []))
  | Global v1 -> 
      let v1 = Ocaml.vof_string v1 in
      Ocaml.VSum (("Global", [ v1 ]))
  
let vof_special =
  function
  | UseStrict -> Ocaml.VSum (("UseStrict", []))
  | Null -> Ocaml.VSum (("Null", []))
  | Undefined -> Ocaml.VSum (("Undefined", []))
  | This -> Ocaml.VSum (("This", []))
  | Super -> Ocaml.VSum (("Super", []))
  | Require -> Ocaml.VSum (("Require", []))
  | Exports -> Ocaml.VSum (("Exports", []))
  | Module -> Ocaml.VSum (("Module", []))
  | Define -> Ocaml.VSum (("Define", []))
  | Arguments -> Ocaml.VSum (("Arguments", []))
  | New -> Ocaml.VSum (("New", []))
  | NewTarget -> Ocaml.VSum (("NewTarget", []))
  | Eval -> Ocaml.VSum (("Eval", []))
  | Seq -> Ocaml.VSum (("Seq", []))
  | Typeof -> Ocaml.VSum (("Typeof", []))
  | Instanceof -> Ocaml.VSum (("Instanceof", []))
  | In -> Ocaml.VSum (("In", []))
  | Delete -> Ocaml.VSum (("Delete", []))
  | Void -> Ocaml.VSum (("Void", []))
  | Spread -> Ocaml.VSum (("Spread", []))
  | Yield -> Ocaml.VSum (("Yield", []))
  | YieldStar -> Ocaml.VSum (("YieldStar", []))
  | Await -> Ocaml.VSum (("Await", []))
  | Encaps v1 ->
      let v1 = Ocaml.vof_option vof_name v1
      in Ocaml.VSum (("Encaps", [ v1 ]))
  | ArithOp x -> Meta_ast_generic_common.vof_arithmetic_operator x
  | IncrDecr v1 -> let v1 = Meta_ast_generic_common.vof_inc_dec v1 in 
      Ocaml.VSum (("IncrDecr", [ v1 ]))
  
let vof_label v = vof_wrap Ocaml.vof_string v
  
let vof_filename v = vof_wrap Ocaml.vof_string v
  
let rec vof_property_name =
  function
  | PN v1 -> let v1 = vof_name v1 in Ocaml.VSum (("PN", [ v1 ]))
  | PN_Computed v1 ->
      let v1 = vof_expr v1 in Ocaml.VSum (("PN_Computed", [ v1 ]))
and vof_expr =
  function
  | Arr v1 ->
     let v1 = vof_bracket (Ocaml.vof_list vof_expr) v1 in Ocaml.VSum (("Arr", [v1]))
  | Bool v1 ->
      let v1 = vof_wrap Ocaml.vof_bool v1 in Ocaml.VSum (("Bool", [ v1 ]))
  | Num v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1 in Ocaml.VSum (("Num", [ v1 ]))
  | String v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("String", [ v1 ]))
  | Regexp v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("Regexp", [ v1 ]))
  | Id (v1, v2) -> 
      let v1 = vof_name v1 in 
      let v2 = Ocaml.vof_ref vof_resolved_name v2 in
      Ocaml.VSum (("Id", [ v1; v2 ]))
  | IdSpecial v1 ->
      let v1 = vof_wrap vof_special v1 in Ocaml.VSum (("IdSpecial", [ v1 ]))
  | Nop -> Ocaml.VSum (("Nop", []))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3 
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
  | ArrAccess ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("ArrAccess", [ v1; v2 ]))
  | Obj v1 -> let v1 = vof_obj_ v1 in Ocaml.VSum (("Obj", [ v1 ]))
  | Ellipsis v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("Ellipsis", [ v1 ]))
  | Class (v1, v2) -> 
     let v1 = vof_class_ v1 in 
     let v2 = Ocaml.vof_option vof_name v2 in
     Ocaml.VSum (("Class", [ v1; v2 ]))
  | ObjAccess ((v1, t, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_property_name v2
      and t = vof_tok t
      in Ocaml.VSum (("ObjAccess", [ v1; t; v2 ]))
  | Fun ((v1, v2)) ->
      let v1 = vof_fun_ v1
      and v2 = Ocaml.vof_option vof_name v2
      in Ocaml.VSum (("Fun", [ v1; v2 ]))
  | Apply ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = Ocaml.vof_list vof_expr v2
      in Ocaml.VSum (("Apply", [ v1; v2 ]))
  | Conditional ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Conditional", [ v1; v2; v3 ]))
and vof_stmt =
  function
  | VarDecl v1 -> let v1 = vof_var v1 in Ocaml.VSum (("VarDecl", [ v1 ]))
  | Block v1 ->
      let v1 = Ocaml.vof_list vof_stmt v1 in Ocaml.VSum (("Block", [ v1 ]))
  | ExprStmt v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("ExprStmt", [ v1 ]))
  | If ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      and v3 = vof_stmt v3
      in Ocaml.VSum (("If", [ t; v1; v2; v3 ]))
  | Do ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_stmt v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Do", [ t; v1; v2 ]))
  | While ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      in Ocaml.VSum (("While", [ t; v1; v2 ]))
  | For ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_for_header v1
      and v2 = vof_stmt v2
      in Ocaml.VSum (("For", [ t; v1; v2 ]))
  | Switch ((v0, v1, v2)) ->
      let v0 = vof_tok v0 in
      let v1 = vof_expr v1
      and v2 = Ocaml.vof_list vof_case v2
      in Ocaml.VSum (("Switch", [ v0; v1; v2 ]))
  | Continue (t, v1) ->
      let t = vof_tok t in
      let v1 = Ocaml.vof_option vof_label v1
      in Ocaml.VSum (("Continue", [ t; v1 ]))
  | Break (t, v1) ->
      let t = vof_tok t in
      let v1 = Ocaml.vof_option vof_label v1
      in Ocaml.VSum (("Break", [ t; v1 ]))
  | Return (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in Ocaml.VSum (("Return", [ t; v1 ]))
  | Label ((v1, v2)) ->
      let v1 = vof_label v1
      and v2 = vof_stmt v2
      in Ocaml.VSum (("Label", [ v1; v2 ]))
  | Throw (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_expr v1 in Ocaml.VSum (("Throw", [ t; v1 ]))
  | Try ((t, v1, v2, v3)) ->
      let t = vof_tok t in
      let v1 = vof_stmt v1
      and v2 =
        Ocaml.vof_option
          (fun (t, v1, v2) ->
             let t = vof_tok t in
             let v1 = vof_wrap Ocaml.vof_string v1
             and v2 = vof_stmt v2
             in Ocaml.VTuple [ t; v1; v2 ])
          v2
      and v3 = Ocaml.vof_option vof_tok_and_stmt v3
      in Ocaml.VSum (("Try", [ t; v1; v2; v3 ]))
and vof_tok_and_stmt (t, v) = 
  let t = vof_tok t in
  let v = vof_stmt v in
  Ocaml.VTuple [t; v]
and vof_for_header =
  function
  | ForClassic ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_either (Ocaml.vof_list vof_var) vof_expr v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("ForClassic", [ v1; v2; v3 ]))
  | ForIn ((v1, t, v2)) ->
      let t = vof_tok t in
      let v1 = Ocaml.vof_either vof_var vof_expr v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("ForIn", [ v1; t; v2 ]))
and vof_case =
  function
  | Case ((t, v1, v2)) ->
      let t = vof_tok t in
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      in Ocaml.VSum (("Case", [ t; v1; v2 ]))
  | Default (t, v1) -> 
      let t = vof_tok t in
      let v1 = vof_stmt v1 in Ocaml.VSum (("Default", [ t; v1 ]))
and vof_var { v_name = v_v_name; 
              v_kind = v_v_kind; 
              v_init = v_v_init;
              v_resolved = v_v_resolved;
             } =
  let bnds = [] in
  let arg = Ocaml.vof_ref vof_resolved_name v_v_resolved in
  let bnd = ("v_resolved", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_expr v_v_init in
  let bnd = ("v_init", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_wrap vof_var_kind v_v_kind in
  let bnd = ("v_kind", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_v_name in
  let bnd = ("v_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_var_kind =
  function
  | Var -> Ocaml.VSum (("Var", []))
  | Let -> Ocaml.VSum (("Let", []))
  | Const -> Ocaml.VSum (("Const", []))
and
  vof_fun_ { f_props = v_f_props; f_params = v_f_params; f_body = v_f_body }
           =
  let bnds = [] in
  let arg = vof_stmt v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list vof_parameter_binding v_f_params in
  let bnd = ("f_params", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list (vof_wrap vof_fun_prop) v_f_props in
  let bnd = ("f_props", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds


and vof_parameter_binding =
  function
  | ParamClassic v1 ->
      let v1 = vof_parameter v1 in Ocaml.VSum (("ParamClassic", [ v1 ]))
  | ParamEllipsis v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("ParamEllipsis", [ v1 ]))

and  vof_parameter {
                  p_name = v_p_name;
                  p_default = v_p_default;
                  p_dots = v_p_dots
                } =
  let bnds = [] in
  let arg = Ocaml.vof_option vof_tok v_p_dots in
  let bnd = ("p_dots", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_expr v_p_default in
  let bnd = ("p_default", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_p_name in
  let bnd = ("p_name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_fun_prop =
  function
  | Get -> Ocaml.VSum (("Get", []))
  | Set -> Ocaml.VSum (("Set", []))
  | Generator -> Ocaml.VSum (("Generator", []))
  | Async -> Ocaml.VSum (("Async", []))
and vof_obj_ v = vof_bracket (Ocaml.vof_list vof_property) v
and vof_class_ { c_extends = v_c_extends; c_body = v_c_body } =
  let bnds = [] in
  let arg = vof_bracket (Ocaml.vof_list vof_property) v_c_body in
  let bnd = ("c_body", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_expr v_c_extends in
  let bnd = ("c_extends", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_property =
  function
  | Field ((v1, v2, v3)) ->
      let v1 = vof_property_name v1
      and v2 = Ocaml.vof_list (vof_wrap vof_property_prop) v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Field", [ v1; v2; v3 ]))
  | FieldSpread (t, v1) ->
      let t = vof_tok t in
      let v1 = vof_expr v1 in Ocaml.VSum (("FieldSpread", [ t; v1 ]))
and vof_property_prop =
  function
  | Static -> Ocaml.VSum (("Static", []))
  | Public -> Ocaml.VSum (("Public", []))
  | Private -> Ocaml.VSum (("Private", []))
  | Protected -> Ocaml.VSum (("Protected", []))

let vof_module_directive =
  function
  | Import ((t, v1, v2, v3)) ->
      let t =  vof_tok t in
      let v1 = vof_name v1
      and v2 = vof_name v2
      and v3 = vof_filename v3
      in Ocaml.VSum (("Import", [ t; v1; v2; v3 ]))
  | ModuleAlias ((t, v1, v2)) ->
      let t =  vof_tok t in
      let v1 = vof_name v1
      and v2 = vof_filename v2
      in Ocaml.VSum (("ModuleAlias", [ t; v1; v2 ]))
  | ImportCss ((v1)) ->
      let v1 = vof_filename v1
      in Ocaml.VSum (("ImportCss", [ v1 ]))
  | ImportEffect ((v1)) ->
      let v1 = vof_filename v1
      in Ocaml.VSum (("ImportEffect", [ v1 ]))
  | Export ((v1)) ->
      let v1 = vof_name v1
      in Ocaml.VSum (("Export", [ v1 ]))
  
let vof_toplevel =
  function
  | S (v1, v2) -> 
     let v1 = vof_tok v1 in let v2 = vof_stmt v2 in
     Ocaml.VSum (("S", [ v1; v2 ]))
  | V v1 ->
     let v1 = vof_var v1 in
     Ocaml.VSum (("V", [v1]))
  | M v1 ->
     let v1 = vof_module_directive v1 in
     Ocaml.VSum (("V", [v1]))

  
let vof_program v = Ocaml.vof_list vof_toplevel v
  
let vof_any =
  function
  | Expr v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Expr", [ v1 ]))
  | Top v1 -> let v1 = vof_toplevel v1 in Ocaml.VSum (("Top", [ v1 ]))
  | Stmt v1 -> let v1 = vof_stmt v1 in Ocaml.VSum (("Stmt", [ v1 ]))
  | Stmts v1 -> let v1 = Ocaml.vof_list vof_stmt v1 in 
      Ocaml.VSum (("Stmt", [ v1 ]))
  | Program v1 -> let v1 = vof_program v1 in Ocaml.VSum (("Program", [ v1 ]))
